{
  "nodes": [
    {
      "id": "sqliteAgentMemory_0",
      "position": {
        "x": 255.61373758408138,
        "y": 718.9806469569425
      },
      "type": "customNode",
      "data": {
        "id": "sqliteAgentMemory_0",
        "label": "SQLite Agent Memory",
        "version": 1,
        "name": "sqliteAgentMemory",
        "type": "SQLiteAgentMemory",
        "baseClasses": [
          "SQLiteAgentMemory",
          "BaseCheckpointSaver"
        ],
        "category": "Memory",
        "description": "Memory for agentflow to remember the state of the conversation using SQLite database",
        "inputParams": [
          {
            "label": "Additional Connection Configuration",
            "name": "additionalConfig",
            "type": "json",
            "additionalParams": true,
            "optional": true,
            "id": "sqliteAgentMemory_0-input-additionalConfig-json"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "additionalConfig": ""
        },
        "outputAnchors": [
          {
            "id": "sqliteAgentMemory_0-output-sqliteAgentMemory-SQLiteAgentMemory|BaseCheckpointSaver",
            "name": "sqliteAgentMemory",
            "label": "SQLiteAgentMemory",
            "description": "Memory for agentflow to remember the state of the conversation using SQLite database",
            "type": "SQLiteAgentMemory | BaseCheckpointSaver"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 253,
      "positionAbsolute": {
        "x": 255.61373758408138,
        "y": 718.9806469569425
      },
      "selected": false,
      "dragging": false
    },
    {
      "id": "seqAgent_0",
      "position": {
        "x": 1900.2094952754364,
        "y": -124.3042016303168
      },
      "type": "customNode",
      "data": {
        "id": "seqAgent_0",
        "label": "Agent",
        "version": 4.1,
        "name": "seqAgent",
        "type": "Agent",
        "baseClasses": [
          "Agent"
        ],
        "category": "Sequential Agents",
        "description": "Agent that can execute tools",
        "inputParams": [
          {
            "label": "Agent Name",
            "name": "agentName",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqAgent_0-input-agentName-string"
          },
          {
            "label": "System Prompt",
            "name": "systemMessagePrompt",
            "type": "string",
            "rows": 4,
            "optional": true,
            "default": "You are a research assistant who can search for up-to-date info using search engine.",
            "id": "seqAgent_0-input-systemMessagePrompt-string"
          },
          {
            "label": "Prepend Messages History",
            "name": "messageHistory",
            "description": "Prepend a list of messages between System Prompt and Human Prompt. This is useful when you want to provide few shot examples",
            "type": "code",
            "hideCodeExecute": true,
            "codeExample": "const { AIMessage, HumanMessage, ToolMessage } = require('@langchain/core/messages');\n\nreturn [\n    new HumanMessage(\"What is 333382 ðŸ¦œ 1932?\"),\n    new AIMessage({\n        content: \"\",\n        tool_calls: [\n        {\n            id: \"12345\",\n            name: \"calulator\",\n            args: {\n                number1: 333382,\n                number2: 1932,\n                operation: \"divide\",\n            },\n        },\n        ],\n    }),\n    new ToolMessage({\n        tool_call_id: \"12345\",\n        content: \"The answer is 172.558.\",\n    }),\n    new AIMessage(\"The answer is 172.558.\"),\n]",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_0-input-messageHistory-code"
          },
          {
            "label": "Conversation History",
            "name": "conversationHistorySelection",
            "type": "options",
            "options": [
              {
                "label": "User Question",
                "name": "user_question",
                "description": "Use the user question from the historical conversation messages as input."
              },
              {
                "label": "Last Conversation Message",
                "name": "last_message",
                "description": "Use the last conversation message from the historical conversation messages as input."
              },
              {
                "label": "All Conversation Messages",
                "name": "all_messages",
                "description": "Use all conversation messages from the historical conversation messages as input."
              },
              {
                "label": "Empty",
                "name": "empty",
                "description": "Do not use any messages from the conversation history. Ensure to use either System Prompt, Human Prompt, or Messages History."
              }
            ],
            "default": "all_messages",
            "optional": true,
            "description": "Select which messages from the conversation history to include in the prompt. The selected messages will be inserted between the System Prompt (if defined) and [Messages History, Human Prompt].",
            "additionalParams": true,
            "id": "seqAgent_0-input-conversationHistorySelection-options"
          },
          {
            "label": "Human Prompt",
            "name": "humanMessagePrompt",
            "type": "string",
            "description": "This prompt will be added at the end of the messages as human message",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_0-input-humanMessagePrompt-string"
          },
          {
            "label": "Require Approval",
            "name": "interrupt",
            "description": "Pause execution and request user approval before running tools.\nIf enabled, the agent will prompt the user with customizable approve/reject options\nand will proceed only after approval. This requires a configured agent memory to manage\nthe state and handle approval requests.\nIf no tools are invoked, the agent proceeds without interruption.",
            "type": "boolean",
            "optional": true,
            "id": "seqAgent_0-input-interrupt-boolean"
          },
          {
            "label": "Format Prompt Values",
            "name": "promptValues",
            "description": "Assign values to the prompt variables. You can also use $flow.state.<variable-name> to get the state value",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "id": "seqAgent_0-input-promptValues-json"
          },
          {
            "label": "Approval Prompt",
            "name": "approvalPrompt",
            "description": "Prompt for approval. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "You are about to execute tool: {tools}. Ask if user want to proceed",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_0-input-approvalPrompt-string"
          },
          {
            "label": "Approve Button Text",
            "name": "approveButtonText",
            "description": "Text for approve button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "Yes",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_0-input-approveButtonText-string"
          },
          {
            "label": "Reject Button Text",
            "name": "rejectButtonText",
            "description": "Text for reject button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "No",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_0-input-rejectButtonText-string"
          },
          {
            "label": "Update State",
            "name": "updateStateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedUpdateStateMemoryTab",
            "additionalParams": true,
            "default": "updateStateMemoryUI",
            "tabs": [
              {
                "label": "Update State (Table)",
                "name": "updateStateMemoryUI",
                "type": "datagrid",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Key and value pair to be updated. For example: if you have the following State:\n    | Key       | Operation     | Default Value     |\n    |-----------|---------------|-------------------|\n    | user      | Replace       |                   |\n\n    You can update the \"user\" value with the following:\n    | Key       | Value     |\n    |-----------|-----------|\n    | user      | john doe  |\n\n2. If you want to use the Agent's output as the value to update state, it is available as available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": \"Hello! How can I assist you today?\",\n        \"usedTools\": [\n            {\n                \"tool\": \"tool-name\",\n                \"toolInput\": \"{foo: var}\",\n                \"toolOutput\": \"This is the tool's output\"\n            }\n        ],\n        \"sourceDocuments\": [\n            {\n                \"pageContent\": \"This is the page content\",\n                \"metadata\": \"{foo: var}\"\n            }\n        ]\n    }\n    ```\n\n    For example, if the `toolOutput` is the value you want to update the state with, you can do the following:\n    | Key       | Value                                     |\n    |-----------|-------------------------------------------|\n    | user      | `$flow.output.usedTools[0].toolOutput`  |\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values",
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "type": "asyncSingleSelect",
                    "loadMethod": "loadStateKeys",
                    "flex": 0.5,
                    "editable": true
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "type": "freeSolo",
                    "valueOptions": [
                      {
                        "label": "Agent Output (string)",
                        "value": "$flow.output.content"
                      },
                      {
                        "label": "Used Tools (array)",
                        "value": "$flow.output.usedTools"
                      },
                      {
                        "label": "First Tool Output (string)",
                        "value": "$flow.output.usedTools[0].toolOutput"
                      },
                      {
                        "label": "Source Documents (array)",
                        "value": "$flow.output.sourceDocuments"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      },
                      {
                        "label": "Input Question (string)",
                        "value": "$flow.input"
                      },
                      {
                        "label": "Session Id (string)",
                        "value": "$flow.sessionId"
                      },
                      {
                        "label": "Chat Id (string)",
                        "value": "$flow.chatId"
                      },
                      {
                        "label": "Chatflow Id (string)",
                        "value": "$flow.chatflowId"
                      }
                    ],
                    "editable": true,
                    "flex": 1
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Update State (Code)",
                "name": "updateStateMemoryCode",
                "type": "code",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Return the key value JSON object. For example: if you have the following State:\n    ```json\n    {\n        \"user\": null\n    }\n    ```\n\n    You can update the \"user\" value by returning the following:\n    ```js\n    return {\n        \"user\": \"john doe\"\n    }\n    ```\n\n2. If you want to use the agent's output as the value to update state, it is available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": \"Hello! How can I assist you today?\",\n        \"usedTools\": [\n            {\n                \"tool\": \"tool-name\",\n                \"toolInput\": \"{foo: var}\",\n                \"toolOutput\": \"This is the tool's output\"\n            }\n        ],\n        \"sourceDocuments\": [\n            {\n                \"pageContent\": \"This is the page content\",\n                \"metadata\": \"{foo: var}\"\n            }\n        ]\n    }\n    ```\n\n    For example, if the `toolOutput` is the value you want to update the state with, you can return the following:\n    ```js\n    return {\n        \"user\": $flow.output.usedTools[0].toolOutput\n    }\n    ```\n\n3. You can also get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values. Must return an object representing the state",
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output;\n\n/* Suppose we have a custom State schema like this:\n* {\n    aggregate: {\n        value: (x, y) => x.concat(y),\n        default: () => []\n    }\n  }\n*/\n\nreturn {\n  aggregate: [result.content]\n};",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqAgent_0-input-updateStateMemory-tabs"
          },
          {
            "label": "Max Iterations",
            "name": "maxIterations",
            "type": "number",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_0-input-maxIterations-number"
          }
        ],
        "inputAnchors": [
          {
            "label": "Tools",
            "name": "tools",
            "type": "Tool",
            "list": true,
            "optional": true,
            "id": "seqAgent_0-input-tools-Tool"
          },
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqAgent_0-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          },
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "optional": true,
            "description": "Overwrite model to be used for this agent",
            "id": "seqAgent_0-input-model-BaseChatModel"
          }
        ],
        "inputs": {
          "agentName": "FileWizard",
          "systemMessagePrompt": "You are a research assistant who can search for up-to-date info using search engine.You are a file system expert who can manipulate and organize digital content. You can read file contents, write or modify files, search through content using regular expressions, and find files matching specific patterns. Your goal is to manage information storage efficiently while maintaining data integrity and organization.",
          "messageHistory": "",
          "conversationHistorySelection": "last_message",
          "humanMessagePrompt": "",
          "tools": [
            "{{customMCP_1.data.instance}}"
          ],
          "sequentialNode": [
            "{{seqCondition_0.data.instance}}"
          ],
          "model": "",
          "interrupt": "",
          "promptValues": "",
          "approvalPrompt": "You are about to execute tool: {tools}. Ask if user want to proceed",
          "approveButtonText": "Yes",
          "rejectButtonText": "No",
          "updateStateMemory": "updateStateMemoryUI",
          "maxIterations": ""
        },
        "outputAnchors": [
          {
            "id": "seqAgent_0-output-seqAgent-Agent",
            "name": "seqAgent",
            "label": "Agent",
            "description": "Agent that can execute tools",
            "type": "Agent"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 861,
      "selected": false,
      "positionAbsolute": {
        "x": 1900.2094952754364,
        "y": -124.3042016303168
      },
      "dragging": false
    },
    {
      "id": "seqStart_0",
      "position": {
        "x": 688.8477229785801,
        "y": 779.2785297017463
      },
      "type": "customNode",
      "data": {
        "id": "seqStart_0",
        "label": "Start",
        "version": 2,
        "name": "seqStart",
        "type": "Start",
        "baseClasses": [
          "Start"
        ],
        "category": "Sequential Agents",
        "description": "Starting point of the conversation",
        "inputParams": [],
        "inputAnchors": [
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "description": "Only compatible with models that are capable of function calling: ChatOpenAI, ChatMistral, ChatAnthropic, ChatGoogleGenerativeAI, ChatVertexAI, GroqChat",
            "id": "seqStart_0-input-model-BaseChatModel"
          },
          {
            "label": "Agent Memory",
            "name": "agentMemory",
            "type": "BaseCheckpointSaver",
            "description": "Save the state of the agent",
            "optional": true,
            "id": "seqStart_0-input-agentMemory-BaseCheckpointSaver"
          },
          {
            "label": "State",
            "name": "state",
            "type": "State",
            "description": "State is an object that is updated by nodes in the graph, passing from one node to another. By default, state contains \"messages\" that got updated with each message sent and received.",
            "optional": true,
            "id": "seqStart_0-input-state-State"
          },
          {
            "label": "Input Moderation",
            "description": "Detect text that could generate harmful output and prevent it from being sent to the language model",
            "name": "inputModeration",
            "type": "Moderation",
            "optional": true,
            "list": true,
            "id": "seqStart_0-input-inputModeration-Moderation"
          }
        ],
        "inputs": {
          "model": "{{chatGoogleGenerativeAI_0.data.instance}}",
          "agentMemory": "{{sqliteAgentMemory_0.data.instance}}",
          "state": "{{seqState_0.data.instance}}",
          "inputModeration": ""
        },
        "outputAnchors": [
          {
            "id": "seqStart_0-output-seqStart-Start",
            "name": "seqStart",
            "label": "Start",
            "description": "Starting point of the conversation",
            "type": "Start"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 383,
      "positionAbsolute": {
        "x": 688.8477229785801,
        "y": 779.2785297017463
      },
      "selected": false,
      "dragging": false
    },
    {
      "id": "seqState_0",
      "position": {
        "x": 254.26473752593864,
        "y": 980.7965400267974
      },
      "type": "customNode",
      "data": {
        "id": "seqState_0",
        "label": "State",
        "version": 2,
        "name": "seqState",
        "type": "State",
        "baseClasses": [
          "State"
        ],
        "category": "Sequential Agents",
        "description": "A centralized state object, updated by nodes in the graph, passing from one node to another",
        "inputParams": [
          {
            "label": "Custom State",
            "name": "stateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedStateTab",
            "additionalParams": true,
            "default": "stateMemoryUI",
            "tabs": [
              {
                "label": "Custom State (Table)",
                "name": "stateMemoryUI",
                "type": "datagrid",
                "description": "Structure for state. By default, state contains \"messages\" that got updated with each message sent and received.",
                "hint": {
                  "label": "How to use",
                  "value": "\nSpecify the Key, Operation Type, and Default Value for the state object. The Operation Type can be either \"Replace\" or \"Append\".\n\n**Replace**\n- Replace the existing value with the new value.\n- If the new value is null, the existing value will be retained.\n\n**Append**\n- Append the new value to the existing value.\n- Default value can be empty or an array. Ex: [\"a\", \"b\"]\n- Final value is an array.\n"
                },
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "editable": true
                  },
                  {
                    "field": "type",
                    "headerName": "Operation",
                    "type": "singleSelect",
                    "valueOptions": [
                      "Replace",
                      "Append"
                    ],
                    "editable": true
                  },
                  {
                    "field": "defaultValue",
                    "headerName": "Default Value",
                    "flex": 1,
                    "editable": true
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Custom State (Code)",
                "name": "stateMemoryCode",
                "type": "code",
                "description": "JSON object representing the state",
                "hideCodeExecute": true,
                "codeExample": "{\n    aggregate: {\n        value: (x, y) => x.concat(y), // here we append the new message to the existing messages\n        default: () => []\n    }\n}",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqState_0-input-stateMemory-tabs"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "stateMemory": "stateMemoryUI",
          "stateMemoryUI": "[{\"key\":\"next\",\"type\":\"Replace\",\"defaultValue\":\"\",\"actions\":\"\",\"id\":1},{\"key\":\"plan\",\"type\":\"Replace\",\"defaultValue\":\"\",\"actions\":\"\",\"id\":2}]"
        },
        "outputAnchors": [
          {
            "id": "seqState_0-output-seqState-State",
            "name": "seqState",
            "label": "State",
            "description": "A centralized state object, updated by nodes in the graph, passing from one node to another",
            "type": "State"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 253,
      "selected": false,
      "positionAbsolute": {
        "x": 254.26473752593864,
        "y": 980.7965400267974
      },
      "dragging": false
    },
    {
      "id": "seqLLMNode_0",
      "position": {
        "x": 1025.716175862355,
        "y": 777.3886229048699
      },
      "type": "customNode",
      "data": {
        "id": "seqLLMNode_0",
        "label": "LLM Node",
        "version": 4.1,
        "name": "seqLLMNode",
        "type": "LLMNode",
        "baseClasses": [
          "LLMNode"
        ],
        "category": "Sequential Agents",
        "description": "Run Chat Model and return the output",
        "inputParams": [
          {
            "label": "Name",
            "name": "llmNodeName",
            "type": "string",
            "placeholder": "LLM",
            "id": "seqLLMNode_0-input-llmNodeName-string"
          },
          {
            "label": "System Prompt",
            "name": "systemMessagePrompt",
            "type": "string",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_0-input-systemMessagePrompt-string"
          },
          {
            "label": "Prepend Messages History",
            "name": "messageHistory",
            "description": "Prepend a list of messages between System Prompt and Human Prompt. This is useful when you want to provide few shot examples",
            "type": "code",
            "hideCodeExecute": true,
            "codeExample": "const { AIMessage, HumanMessage, ToolMessage } = require('@langchain/core/messages');\n\nreturn [\n    new HumanMessage(\"What is 333382 ðŸ¦œ 1932?\"),\n    new AIMessage({\n        content: \"\",\n        tool_calls: [\n        {\n            id: \"12345\",\n            name: \"calulator\",\n            args: {\n                number1: 333382,\n                number2: 1932,\n                operation: \"divide\",\n            },\n        },\n        ],\n    }),\n    new ToolMessage({\n        tool_call_id: \"12345\",\n        content: \"The answer is 172.558.\",\n    }),\n    new AIMessage(\"The answer is 172.558.\"),\n]",
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_0-input-messageHistory-code"
          },
          {
            "label": "Conversation History",
            "name": "conversationHistorySelection",
            "type": "options",
            "options": [
              {
                "label": "User Question",
                "name": "user_question",
                "description": "Use the user question from the historical conversation messages as input."
              },
              {
                "label": "Last Conversation Message",
                "name": "last_message",
                "description": "Use the last conversation message from the historical conversation messages as input."
              },
              {
                "label": "All Conversation Messages",
                "name": "all_messages",
                "description": "Use all conversation messages from the historical conversation messages as input."
              },
              {
                "label": "Empty",
                "name": "empty",
                "description": "Do not use any messages from the conversation history. Ensure to use either System Prompt, Human Prompt, or Messages History."
              }
            ],
            "default": "all_messages",
            "optional": true,
            "description": "Select which messages from the conversation history to include in the prompt. The selected messages will be inserted between the System Prompt (if defined) and [Messages History, Human Prompt].",
            "additionalParams": true,
            "id": "seqLLMNode_0-input-conversationHistorySelection-options"
          },
          {
            "label": "Human Prompt",
            "name": "humanMessagePrompt",
            "type": "string",
            "description": "This prompt will be added at the end of the messages as human message",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_0-input-humanMessagePrompt-string"
          },
          {
            "label": "Format Prompt Values",
            "name": "promptValues",
            "description": "Assign values to the prompt variables. You can also use $flow.state.<variable-name> to get the state value",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "additionalParams": true,
            "id": "seqLLMNode_0-input-promptValues-json"
          },
          {
            "label": "JSON Structured Output",
            "name": "llmStructuredOutput",
            "type": "datagrid",
            "description": "Instruct the LLM to give output in a JSON structured schema",
            "datagrid": [
              {
                "field": "key",
                "headerName": "Key",
                "editable": true
              },
              {
                "field": "type",
                "headerName": "Type",
                "type": "singleSelect",
                "valueOptions": [
                  "String",
                  "String Array",
                  "Number",
                  "Boolean",
                  "Enum"
                ],
                "editable": true
              },
              {
                "field": "enumValues",
                "headerName": "Enum Values",
                "editable": true
              },
              {
                "field": "description",
                "headerName": "Description",
                "flex": 1,
                "editable": true
              }
            ],
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_0-input-llmStructuredOutput-datagrid"
          },
          {
            "label": "Update State",
            "name": "updateStateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedUpdateStateMemoryTab",
            "default": "updateStateMemoryUI",
            "additionalParams": true,
            "tabs": [
              {
                "label": "Update State (Table)",
                "name": "updateStateMemoryUI",
                "type": "datagrid",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Key and value pair to be updated. For example: if you have the following State:\n    | Key       | Operation     | Default Value     |\n    |-----------|---------------|-------------------|\n    | user      | Replace       |                   |\n\n    You can update the \"user\" value with the following:\n    | Key       | Value     |\n    |-----------|-----------|\n    | user      | john doe  |\n\n2. If you want to use the LLM Node's output as the value to update state, it is available as available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": 'Hello! How can I assist you today?',\n        \"name\": \"\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {},\n        \"tool_calls\": [],\n        \"invalid_tool_calls\": [],\n        \"usage_metadata\": {}\n    }\n    ```\n\n    For example, if the output `content` is the value you want to update the state with, you can do the following:\n    | Key       | Value                     |\n    |-----------|---------------------------|\n    | user      | `$flow.output.content`  |\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values",
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "type": "asyncSingleSelect",
                    "loadMethod": "loadStateKeys",
                    "flex": 0.5,
                    "editable": true
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "type": "freeSolo",
                    "valueOptions": [
                      {
                        "label": "LLM Node Output (string)",
                        "value": "$flow.output.content"
                      },
                      {
                        "label": "LLM JSON Output Key (string)",
                        "value": "$flow.output.<replace-with-key>"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      },
                      {
                        "label": "Input Question (string)",
                        "value": "$flow.input"
                      },
                      {
                        "label": "Session Id (string)",
                        "value": "$flow.sessionId"
                      },
                      {
                        "label": "Chat Id (string)",
                        "value": "$flow.chatId"
                      },
                      {
                        "label": "Chatflow Id (string)",
                        "value": "$flow.chatflowId"
                      }
                    ],
                    "editable": true,
                    "flex": 1
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Update State (Code)",
                "name": "updateStateMemoryCode",
                "type": "code",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Return the key value JSON object. For example: if you have the following State:\n    ```json\n    {\n        \"user\": null\n    }\n    ```\n\n    You can update the \"user\" value by returning the following:\n    ```js\n    return {\n        \"user\": \"john doe\"\n    }\n    ```\n\n2. If you want to use the LLM Node's output as the value to update state, it is available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": 'Hello! How can I assist you today?',\n        \"name\": \"\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {},\n        \"tool_calls\": [],\n        \"invalid_tool_calls\": [],\n        \"usage_metadata\": {}\n    }\n    ```\n\n    For example, if the output `content` is the value you want to update the state with, you can return the following:\n    ```js\n    return {\n        \"user\": $flow.output.content\n    }\n    ```\n\n3. You can also get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values. Must return an object representing the state",
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output;\n\n/* Suppose we have a custom State schema like this:\n* {\n    aggregate: {\n        value: (x, y) => x.concat(y),\n        default: () => []\n    }\n  }\n*/\n\nreturn {\n  aggregate: [result.content]\n};",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqLLMNode_0-input-updateStateMemory-tabs"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, Condition, LLM, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLLMNode_0-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          },
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "optional": true,
            "description": "Overwrite model to be used for this node",
            "id": "seqLLMNode_0-input-model-BaseChatModel"
          }
        ],
        "inputs": {
          "llmNodeName": "Supervisor",
          "systemMessagePrompt": "You are Supervisor, an AI agent created by BarrelOfLube and inspired from Manus.\n\nYou excel at the following tasks:\n1. Information gathering, fact-checking, and documentation\n2. Data processing, analysis, and visualization\n3. Writing multi-chapter articles and in-depth research reports\n4. Creating websites, applications, and tools\n5. Using programming to solve various problems beyond development\n6. Various tasks that can be accomplished using computers and the internet\n\nDefault working language: English\nUse the language specified by user in messages as the working language when explicitly provided\nAll thinking and responses must be in the working language\nNatural language arguments in tool calls must be in the working language\nAvoid using pure lists and bullet points format in any language\n\nSystem capabilities:\n- Access a Linux sandbox environment with internet connection\n- Use shell, text editor, browser, and other software\n- Write and run code in Python and various programming languages\n- Independently install required software packages and dependencies via shell\n- Deploy websites or applications and provide public access\n- Suggest users to temporarily take control of the browser for sensitive operations when necessary\n- Utilize various tools to complete user-assigned tasks step by step\n\nYou operate in an agent loop, iteratively completing tasks through these steps:\n1. Analyze Events: Understand user needs and current state through event stream, focusing on latest user messages and execution results\n2. Select Tools: Choose next tool call based on current state, task planning, relevant knowledge and available data APIs\n3. Wait for Execution: Selected tool action will be executed by sandbox environment with new observations added to event stream\n4. Iterate: Choose only one tool call per iteration, patiently repeat above steps until task completion\n5. Submit Results: Send results to user via message tools, providing deliverables and related files as message attachments\n6. Enter Standby: Enter FINISH state when all tasks are completed or user explicitly requests to stop, and wait for new tasks",
          "messageHistory": "",
          "conversationHistorySelection": "all_messages",
          "humanMessagePrompt": "",
          "sequentialNode": [
            "{{seqStart_0.data.instance}}"
          ],
          "model": "",
          "promptValues": "",
          "llmStructuredOutput": "[{\"key\":\"next\",\"type\":\"Enum\",\"enumValues\":\"FINISH, Planner, Communicator, FileWizard, CommandRunner, WebNavigator\",\"description\":\"\",\"actions\":\"\",\"id\":0},{\"key\":\"instructions\",\"type\":\"String\",\"enumValues\":\"The specific instructions of the sub-task the next role should accomplish.\",\"description\":\"\",\"actions\":\"\",\"id\":1}]",
          "updateStateMemory": "updateStateMemoryUI",
          "updateStateMemoryUI": "[{\"key\":\"next\",\"value\":\"$flow.output.next\",\"actions\":\"\",\"id\":1}]"
        },
        "outputAnchors": [
          {
            "id": "seqLLMNode_0-output-seqLLMNode-LLMNode",
            "name": "seqLLMNode",
            "label": "LLMNode",
            "description": "Run Chat Model and return the output",
            "type": "LLMNode"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 433,
      "selected": false,
      "positionAbsolute": {
        "x": 1025.716175862355,
        "y": 777.3886229048699
      },
      "dragging": false
    },
    {
      "id": "seqCondition_0",
      "position": {
        "x": 1361.2071210554777,
        "y": 774.9175035890597
      },
      "type": "customNode",
      "data": {
        "id": "seqCondition_0",
        "label": "Condition",
        "version": 2.1,
        "name": "seqCondition",
        "type": "Condition",
        "baseClasses": [
          "Condition"
        ],
        "category": "Sequential Agents",
        "description": "Conditional function to determine which route to take next",
        "inputParams": [
          {
            "label": "Condition Name",
            "name": "conditionName",
            "type": "string",
            "optional": true,
            "placeholder": "If X, then Y",
            "id": "seqCondition_0-input-conditionName-string"
          },
          {
            "label": "Condition",
            "name": "condition",
            "type": "conditionFunction",
            "tabIdentifier": "selectedConditionFunctionTab",
            "tabs": [
              {
                "label": "Condition (Table)",
                "name": "conditionUI",
                "type": "datagrid",
                "description": "If a condition is met, the node connected to the respective output will be executed",
                "optional": true,
                "datagrid": [
                  {
                    "field": "variable",
                    "headerName": "Variable",
                    "type": "freeSolo",
                    "editable": true,
                    "loadMethod": [
                      "getPreviousMessages",
                      "loadStateKeys"
                    ],
                    "valueOptions": [
                      {
                        "label": "Total Messages (number)",
                        "value": "$flow.state.messages.length"
                      },
                      {
                        "label": "First Message Content (string)",
                        "value": "$flow.state.messages[0].content"
                      },
                      {
                        "label": "Last Message Content (string)",
                        "value": "$flow.state.messages[-1].content"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      }
                    ],
                    "flex": 0.5,
                    "minWidth": 200
                  },
                  {
                    "field": "operation",
                    "headerName": "Operation",
                    "type": "singleSelect",
                    "valueOptions": [
                      "Contains",
                      "Not Contains",
                      "Start With",
                      "End With",
                      "Is",
                      "Is Not",
                      "Is Empty",
                      "Is Not Empty",
                      "Greater Than",
                      "Less Than",
                      "Equal To",
                      "Not Equal To",
                      "Greater Than or Equal To",
                      "Less Than or Equal To"
                    ],
                    "editable": true,
                    "flex": 0.4,
                    "minWidth": 150
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "flex": 1,
                    "editable": true
                  },
                  {
                    "field": "output",
                    "headerName": "Output Name",
                    "editable": true,
                    "flex": 0.3,
                    "minWidth": 150
                  }
                ]
              },
              {
                "label": "Condition (Code)",
                "name": "conditionFunction",
                "type": "code",
                "description": "Function to evaluate the condition",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Must return a string value at the end of function. For example:\n    ```js\n    if (\"X\" === \"X\") {\n        return \"Agent\"; // connect to next agent node\n    } else {\n        return \"End\"; // connect to end node\n    }\n    ```\n\n2. In most cases, you would probably get the last message to do some comparison. You can get all current messages from the state: `$flow.state.messages`:\n    ```json\n    [\n        {\n            \"content\": \"Hello! How can I assist you today?\",\n            \"name\": \"\",\n            \"additional_kwargs\": {},\n            \"response_metadata\": {},\n            \"tool_calls\": [],\n            \"invalid_tool_calls\": [],\n            \"usage_metadata\": {}\n        }\n    ]\n    ```\n\n    For example, to get the last message content:\n    ```js\n    const messages = $flow.state.messages;\n    const lastMessage = messages[messages.length - 1];\n\n    // Proceed to do something with the last message content\n    ```\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "hideCodeExecute": true,
                "codeExample": "const state = $flow.state;\n                \nconst messages = state.messages;\n\nconst lastMessage = messages[messages.length - 1];\n\n/* Check if the last message has content */\nif (lastMessage.content) {\n    return \"Agent\";\n}\n\nreturn \"End\";",
                "optional": true
              }
            ],
            "id": "seqCondition_0-input-condition-conditionFunction"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqCondition_0-input-sequentialNode-Start | Agent | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "conditionName": "router",
          "sequentialNode": [
            "{{seqLLMNode_0.data.instance}}"
          ],
          "condition": "",
          "conditionUI": "[{\"variable\":\"$flow.state.next\",\"operation\":\"Is\",\"value\":\"Planner\",\"output\":\"Planner\",\"actions\":\"\",\"id\":0},{\"variable\":\"$flow.state.next\",\"operation\":\"Is\",\"value\":\"FileWizard\",\"output\":\"FileWizard\",\"actions\":\"\",\"id\":2},{\"variable\":\"$flow.state.next\",\"operation\":\"Is\",\"value\":\"CommandRunner\",\"output\":\"CommandRunner\",\"actions\":\"\",\"id\":3},{\"variable\":\"$flow.state.next\",\"operation\":\"Is\",\"value\":\"WebNavigator\",\"output\":\"WebNavigator\",\"actions\":\"\",\"id\":4}]",
          "selectedConditionFunctionTab_seqCondition_0": "conditionUI"
        },
        "outputAnchors": [
          {
            "name": "output",
            "label": "Output",
            "type": "options",
            "options": [
              {
                "id": "seqCondition_0-output-commandrunner-Condition",
                "name": "commandrunner",
                "label": "CommandRunner",
                "type": "Condition",
                "isAnchor": true
              },
              {
                "id": "seqCondition_0-output-end-Condition",
                "name": "end",
                "label": "End",
                "type": "Condition",
                "isAnchor": true
              },
              {
                "id": "seqCondition_0-output-filewizard-Condition",
                "name": "filewizard",
                "label": "FileWizard",
                "type": "Condition",
                "isAnchor": true
              },
              {
                "id": "seqCondition_0-output-planner-Condition",
                "name": "planner",
                "label": "Planner",
                "type": "Condition",
                "isAnchor": true
              },
              {
                "id": "seqCondition_0-output-webnavigator-Condition",
                "name": "webnavigator",
                "label": "WebNavigator",
                "type": "Condition",
                "isAnchor": true
              }
            ]
          }
        ],
        "outputs": {
          "output": "next"
        },
        "selected": false
      },
      "width": 300,
      "height": 628,
      "positionAbsolute": {
        "x": 1361.2071210554777,
        "y": 774.9175035890597
      },
      "selected": false,
      "dragging": false
    },
    {
      "id": "seqAgent_1",
      "position": {
        "x": 1899.636411400565,
        "y": 747.012084093667
      },
      "type": "customNode",
      "data": {
        "id": "seqAgent_1",
        "label": "Agent",
        "version": 4.1,
        "name": "seqAgent",
        "type": "Agent",
        "baseClasses": [
          "Agent"
        ],
        "category": "Sequential Agents",
        "description": "Agent that can execute tools",
        "inputParams": [
          {
            "label": "Agent Name",
            "name": "agentName",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqAgent_1-input-agentName-string"
          },
          {
            "label": "System Prompt",
            "name": "systemMessagePrompt",
            "type": "string",
            "rows": 4,
            "optional": true,
            "default": "You are a research assistant who can search for up-to-date info using search engine.",
            "id": "seqAgent_1-input-systemMessagePrompt-string"
          },
          {
            "label": "Prepend Messages History",
            "name": "messageHistory",
            "description": "Prepend a list of messages between System Prompt and Human Prompt. This is useful when you want to provide few shot examples",
            "type": "code",
            "hideCodeExecute": true,
            "codeExample": "const { AIMessage, HumanMessage, ToolMessage } = require('@langchain/core/messages');\n\nreturn [\n    new HumanMessage(\"What is 333382 ðŸ¦œ 1932?\"),\n    new AIMessage({\n        content: \"\",\n        tool_calls: [\n        {\n            id: \"12345\",\n            name: \"calulator\",\n            args: {\n                number1: 333382,\n                number2: 1932,\n                operation: \"divide\",\n            },\n        },\n        ],\n    }),\n    new ToolMessage({\n        tool_call_id: \"12345\",\n        content: \"The answer is 172.558.\",\n    }),\n    new AIMessage(\"The answer is 172.558.\"),\n]",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_1-input-messageHistory-code"
          },
          {
            "label": "Conversation History",
            "name": "conversationHistorySelection",
            "type": "options",
            "options": [
              {
                "label": "User Question",
                "name": "user_question",
                "description": "Use the user question from the historical conversation messages as input."
              },
              {
                "label": "Last Conversation Message",
                "name": "last_message",
                "description": "Use the last conversation message from the historical conversation messages as input."
              },
              {
                "label": "All Conversation Messages",
                "name": "all_messages",
                "description": "Use all conversation messages from the historical conversation messages as input."
              },
              {
                "label": "Empty",
                "name": "empty",
                "description": "Do not use any messages from the conversation history. Ensure to use either System Prompt, Human Prompt, or Messages History."
              }
            ],
            "default": "all_messages",
            "optional": true,
            "description": "Select which messages from the conversation history to include in the prompt. The selected messages will be inserted between the System Prompt (if defined) and [Messages History, Human Prompt].",
            "additionalParams": true,
            "id": "seqAgent_1-input-conversationHistorySelection-options"
          },
          {
            "label": "Human Prompt",
            "name": "humanMessagePrompt",
            "type": "string",
            "description": "This prompt will be added at the end of the messages as human message",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_1-input-humanMessagePrompt-string"
          },
          {
            "label": "Require Approval",
            "name": "interrupt",
            "description": "Pause execution and request user approval before running tools.\nIf enabled, the agent will prompt the user with customizable approve/reject options\nand will proceed only after approval. This requires a configured agent memory to manage\nthe state and handle approval requests.\nIf no tools are invoked, the agent proceeds without interruption.",
            "type": "boolean",
            "optional": true,
            "id": "seqAgent_1-input-interrupt-boolean"
          },
          {
            "label": "Format Prompt Values",
            "name": "promptValues",
            "description": "Assign values to the prompt variables. You can also use $flow.state.<variable-name> to get the state value",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "id": "seqAgent_1-input-promptValues-json"
          },
          {
            "label": "Approval Prompt",
            "name": "approvalPrompt",
            "description": "Prompt for approval. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "You are about to execute tool: {tools}. Ask if user want to proceed",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_1-input-approvalPrompt-string"
          },
          {
            "label": "Approve Button Text",
            "name": "approveButtonText",
            "description": "Text for approve button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "Yes",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_1-input-approveButtonText-string"
          },
          {
            "label": "Reject Button Text",
            "name": "rejectButtonText",
            "description": "Text for reject button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "No",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_1-input-rejectButtonText-string"
          },
          {
            "label": "Update State",
            "name": "updateStateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedUpdateStateMemoryTab",
            "additionalParams": true,
            "default": "updateStateMemoryUI",
            "tabs": [
              {
                "label": "Update State (Table)",
                "name": "updateStateMemoryUI",
                "type": "datagrid",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Key and value pair to be updated. For example: if you have the following State:\n    | Key       | Operation     | Default Value     |\n    |-----------|---------------|-------------------|\n    | user      | Replace       |                   |\n\n    You can update the \"user\" value with the following:\n    | Key       | Value     |\n    |-----------|-----------|\n    | user      | john doe  |\n\n2. If you want to use the Agent's output as the value to update state, it is available as available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": \"Hello! How can I assist you today?\",\n        \"usedTools\": [\n            {\n                \"tool\": \"tool-name\",\n                \"toolInput\": \"{foo: var}\",\n                \"toolOutput\": \"This is the tool's output\"\n            }\n        ],\n        \"sourceDocuments\": [\n            {\n                \"pageContent\": \"This is the page content\",\n                \"metadata\": \"{foo: var}\"\n            }\n        ]\n    }\n    ```\n\n    For example, if the `toolOutput` is the value you want to update the state with, you can do the following:\n    | Key       | Value                                     |\n    |-----------|-------------------------------------------|\n    | user      | `$flow.output.usedTools[0].toolOutput`  |\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values",
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "type": "asyncSingleSelect",
                    "loadMethod": "loadStateKeys",
                    "flex": 0.5,
                    "editable": true
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "type": "freeSolo",
                    "valueOptions": [
                      {
                        "label": "Agent Output (string)",
                        "value": "$flow.output.content"
                      },
                      {
                        "label": "Used Tools (array)",
                        "value": "$flow.output.usedTools"
                      },
                      {
                        "label": "First Tool Output (string)",
                        "value": "$flow.output.usedTools[0].toolOutput"
                      },
                      {
                        "label": "Source Documents (array)",
                        "value": "$flow.output.sourceDocuments"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      },
                      {
                        "label": "Input Question (string)",
                        "value": "$flow.input"
                      },
                      {
                        "label": "Session Id (string)",
                        "value": "$flow.sessionId"
                      },
                      {
                        "label": "Chat Id (string)",
                        "value": "$flow.chatId"
                      },
                      {
                        "label": "Chatflow Id (string)",
                        "value": "$flow.chatflowId"
                      }
                    ],
                    "editable": true,
                    "flex": 1
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Update State (Code)",
                "name": "updateStateMemoryCode",
                "type": "code",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Return the key value JSON object. For example: if you have the following State:\n    ```json\n    {\n        \"user\": null\n    }\n    ```\n\n    You can update the \"user\" value by returning the following:\n    ```js\n    return {\n        \"user\": \"john doe\"\n    }\n    ```\n\n2. If you want to use the agent's output as the value to update state, it is available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": \"Hello! How can I assist you today?\",\n        \"usedTools\": [\n            {\n                \"tool\": \"tool-name\",\n                \"toolInput\": \"{foo: var}\",\n                \"toolOutput\": \"This is the tool's output\"\n            }\n        ],\n        \"sourceDocuments\": [\n            {\n                \"pageContent\": \"This is the page content\",\n                \"metadata\": \"{foo: var}\"\n            }\n        ]\n    }\n    ```\n\n    For example, if the `toolOutput` is the value you want to update the state with, you can return the following:\n    ```js\n    return {\n        \"user\": $flow.output.usedTools[0].toolOutput\n    }\n    ```\n\n3. You can also get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values. Must return an object representing the state",
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output;\n\n/* Suppose we have a custom State schema like this:\n* {\n    aggregate: {\n        value: (x, y) => x.concat(y),\n        default: () => []\n    }\n  }\n*/\n\nreturn {\n  aggregate: [result.content]\n};",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqAgent_1-input-updateStateMemory-tabs"
          },
          {
            "label": "Max Iterations",
            "name": "maxIterations",
            "type": "number",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_1-input-maxIterations-number"
          }
        ],
        "inputAnchors": [
          {
            "label": "Tools",
            "name": "tools",
            "type": "Tool",
            "list": true,
            "optional": true,
            "id": "seqAgent_1-input-tools-Tool"
          },
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqAgent_1-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          },
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "optional": true,
            "description": "Overwrite model to be used for this agent",
            "id": "seqAgent_1-input-model-BaseChatModel"
          }
        ],
        "inputs": {
          "agentName": "CommandRunner",
          "systemMessagePrompt": "You are a research assistant who can search for up-to-date info using search engine.",
          "messageHistory": "",
          "conversationHistorySelection": "last_message",
          "humanMessagePrompt": "",
          "tools": [
            "{{customMCP_2.data.instance}}"
          ],
          "sequentialNode": [
            "{{seqCondition_0.data.instance}}"
          ],
          "model": "",
          "interrupt": "",
          "promptValues": "",
          "approvalPrompt": "You are about to execute tool: {tools}. Ask if user want to proceed",
          "approveButtonText": "Yes",
          "rejectButtonText": "No",
          "updateStateMemory": "updateStateMemoryUI",
          "maxIterations": ""
        },
        "outputAnchors": [
          {
            "id": "seqAgent_1-output-seqAgent-Agent",
            "name": "seqAgent",
            "label": "Agent",
            "description": "Agent that can execute tools",
            "type": "Agent"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 861,
      "selected": false,
      "positionAbsolute": {
        "x": 1899.636411400565,
        "y": 747.012084093667
      },
      "dragging": false
    },
    {
      "id": "seqAgent_2",
      "position": {
        "x": 1897.471716273374,
        "y": 1618.7628075908547
      },
      "type": "customNode",
      "data": {
        "id": "seqAgent_2",
        "label": "Agent",
        "version": 4.1,
        "name": "seqAgent",
        "type": "Agent",
        "baseClasses": [
          "Agent"
        ],
        "category": "Sequential Agents",
        "description": "Agent that can execute tools",
        "inputParams": [
          {
            "label": "Agent Name",
            "name": "agentName",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqAgent_2-input-agentName-string"
          },
          {
            "label": "System Prompt",
            "name": "systemMessagePrompt",
            "type": "string",
            "rows": 4,
            "optional": true,
            "default": "You are a research assistant who can search for up-to-date info using search engine.",
            "id": "seqAgent_2-input-systemMessagePrompt-string"
          },
          {
            "label": "Prepend Messages History",
            "name": "messageHistory",
            "description": "Prepend a list of messages between System Prompt and Human Prompt. This is useful when you want to provide few shot examples",
            "type": "code",
            "hideCodeExecute": true,
            "codeExample": "const { AIMessage, HumanMessage, ToolMessage } = require('@langchain/core/messages');\n\nreturn [\n    new HumanMessage(\"What is 333382 ðŸ¦œ 1932?\"),\n    new AIMessage({\n        content: \"\",\n        tool_calls: [\n        {\n            id: \"12345\",\n            name: \"calulator\",\n            args: {\n                number1: 333382,\n                number2: 1932,\n                operation: \"divide\",\n            },\n        },\n        ],\n    }),\n    new ToolMessage({\n        tool_call_id: \"12345\",\n        content: \"The answer is 172.558.\",\n    }),\n    new AIMessage(\"The answer is 172.558.\"),\n]",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_2-input-messageHistory-code"
          },
          {
            "label": "Conversation History",
            "name": "conversationHistorySelection",
            "type": "options",
            "options": [
              {
                "label": "User Question",
                "name": "user_question",
                "description": "Use the user question from the historical conversation messages as input."
              },
              {
                "label": "Last Conversation Message",
                "name": "last_message",
                "description": "Use the last conversation message from the historical conversation messages as input."
              },
              {
                "label": "All Conversation Messages",
                "name": "all_messages",
                "description": "Use all conversation messages from the historical conversation messages as input."
              },
              {
                "label": "Empty",
                "name": "empty",
                "description": "Do not use any messages from the conversation history. Ensure to use either System Prompt, Human Prompt, or Messages History."
              }
            ],
            "default": "all_messages",
            "optional": true,
            "description": "Select which messages from the conversation history to include in the prompt. The selected messages will be inserted between the System Prompt (if defined) and [Messages History, Human Prompt].",
            "additionalParams": true,
            "id": "seqAgent_2-input-conversationHistorySelection-options"
          },
          {
            "label": "Human Prompt",
            "name": "humanMessagePrompt",
            "type": "string",
            "description": "This prompt will be added at the end of the messages as human message",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_2-input-humanMessagePrompt-string"
          },
          {
            "label": "Require Approval",
            "name": "interrupt",
            "description": "Pause execution and request user approval before running tools.\nIf enabled, the agent will prompt the user with customizable approve/reject options\nand will proceed only after approval. This requires a configured agent memory to manage\nthe state and handle approval requests.\nIf no tools are invoked, the agent proceeds without interruption.",
            "type": "boolean",
            "optional": true,
            "id": "seqAgent_2-input-interrupt-boolean"
          },
          {
            "label": "Format Prompt Values",
            "name": "promptValues",
            "description": "Assign values to the prompt variables. You can also use $flow.state.<variable-name> to get the state value",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "id": "seqAgent_2-input-promptValues-json"
          },
          {
            "label": "Approval Prompt",
            "name": "approvalPrompt",
            "description": "Prompt for approval. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "You are about to execute tool: {tools}. Ask if user want to proceed",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_2-input-approvalPrompt-string"
          },
          {
            "label": "Approve Button Text",
            "name": "approveButtonText",
            "description": "Text for approve button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "Yes",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_2-input-approveButtonText-string"
          },
          {
            "label": "Reject Button Text",
            "name": "rejectButtonText",
            "description": "Text for reject button. Only applicable if \"Require Approval\" is enabled",
            "type": "string",
            "default": "No",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_2-input-rejectButtonText-string"
          },
          {
            "label": "Update State",
            "name": "updateStateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedUpdateStateMemoryTab",
            "additionalParams": true,
            "default": "updateStateMemoryUI",
            "tabs": [
              {
                "label": "Update State (Table)",
                "name": "updateStateMemoryUI",
                "type": "datagrid",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Key and value pair to be updated. For example: if you have the following State:\n    | Key       | Operation     | Default Value     |\n    |-----------|---------------|-------------------|\n    | user      | Replace       |                   |\n\n    You can update the \"user\" value with the following:\n    | Key       | Value     |\n    |-----------|-----------|\n    | user      | john doe  |\n\n2. If you want to use the Agent's output as the value to update state, it is available as available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": \"Hello! How can I assist you today?\",\n        \"usedTools\": [\n            {\n                \"tool\": \"tool-name\",\n                \"toolInput\": \"{foo: var}\",\n                \"toolOutput\": \"This is the tool's output\"\n            }\n        ],\n        \"sourceDocuments\": [\n            {\n                \"pageContent\": \"This is the page content\",\n                \"metadata\": \"{foo: var}\"\n            }\n        ]\n    }\n    ```\n\n    For example, if the `toolOutput` is the value you want to update the state with, you can do the following:\n    | Key       | Value                                     |\n    |-----------|-------------------------------------------|\n    | user      | `$flow.output.usedTools[0].toolOutput`  |\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values",
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "type": "asyncSingleSelect",
                    "loadMethod": "loadStateKeys",
                    "flex": 0.5,
                    "editable": true
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "type": "freeSolo",
                    "valueOptions": [
                      {
                        "label": "Agent Output (string)",
                        "value": "$flow.output.content"
                      },
                      {
                        "label": "Used Tools (array)",
                        "value": "$flow.output.usedTools"
                      },
                      {
                        "label": "First Tool Output (string)",
                        "value": "$flow.output.usedTools[0].toolOutput"
                      },
                      {
                        "label": "Source Documents (array)",
                        "value": "$flow.output.sourceDocuments"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      },
                      {
                        "label": "Input Question (string)",
                        "value": "$flow.input"
                      },
                      {
                        "label": "Session Id (string)",
                        "value": "$flow.sessionId"
                      },
                      {
                        "label": "Chat Id (string)",
                        "value": "$flow.chatId"
                      },
                      {
                        "label": "Chatflow Id (string)",
                        "value": "$flow.chatflowId"
                      }
                    ],
                    "editable": true,
                    "flex": 1
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Update State (Code)",
                "name": "updateStateMemoryCode",
                "type": "code",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Return the key value JSON object. For example: if you have the following State:\n    ```json\n    {\n        \"user\": null\n    }\n    ```\n\n    You can update the \"user\" value by returning the following:\n    ```js\n    return {\n        \"user\": \"john doe\"\n    }\n    ```\n\n2. If you want to use the agent's output as the value to update state, it is available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": \"Hello! How can I assist you today?\",\n        \"usedTools\": [\n            {\n                \"tool\": \"tool-name\",\n                \"toolInput\": \"{foo: var}\",\n                \"toolOutput\": \"This is the tool's output\"\n            }\n        ],\n        \"sourceDocuments\": [\n            {\n                \"pageContent\": \"This is the page content\",\n                \"metadata\": \"{foo: var}\"\n            }\n        ]\n    }\n    ```\n\n    For example, if the `toolOutput` is the value you want to update the state with, you can return the following:\n    ```js\n    return {\n        \"user\": $flow.output.usedTools[0].toolOutput\n    }\n    ```\n\n3. You can also get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values. Must return an object representing the state",
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output;\n\n/* Suppose we have a custom State schema like this:\n* {\n    aggregate: {\n        value: (x, y) => x.concat(y),\n        default: () => []\n    }\n  }\n*/\n\nreturn {\n  aggregate: [result.content]\n};",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqAgent_2-input-updateStateMemory-tabs"
          },
          {
            "label": "Max Iterations",
            "name": "maxIterations",
            "type": "number",
            "optional": true,
            "additionalParams": true,
            "id": "seqAgent_2-input-maxIterations-number"
          }
        ],
        "inputAnchors": [
          {
            "label": "Tools",
            "name": "tools",
            "type": "Tool",
            "list": true,
            "optional": true,
            "id": "seqAgent_2-input-tools-Tool"
          },
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqAgent_2-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          },
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "optional": true,
            "description": "Overwrite model to be used for this agent",
            "id": "seqAgent_2-input-model-BaseChatModel"
          }
        ],
        "inputs": {
          "agentName": "WebNavigator",
          "systemMessagePrompt": "You are a research assistant who can search for up-to-date info using search engine.",
          "messageHistory": "",
          "conversationHistorySelection": "last_message",
          "humanMessagePrompt": "",
          "tools": [
            "{{braveSearchAPI_0.data.instance}}",
            "{{customMCP_0.data.instance}}"
          ],
          "sequentialNode": [
            "{{seqCondition_0.data.instance}}"
          ],
          "model": "",
          "interrupt": "",
          "promptValues": "",
          "approvalPrompt": "You are about to execute tool: {tools}. Ask if user want to proceed",
          "approveButtonText": "Yes",
          "rejectButtonText": "No",
          "updateStateMemory": "updateStateMemoryUI",
          "maxIterations": ""
        },
        "outputAnchors": [
          {
            "id": "seqAgent_2-output-seqAgent-Agent",
            "name": "seqAgent",
            "label": "Agent",
            "description": "Agent that can execute tools",
            "type": "Agent"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 861,
      "selected": false,
      "positionAbsolute": {
        "x": 1897.471716273374,
        "y": 1618.7628075908547
      },
      "dragging": false
    },
    {
      "id": "seqLoop_0",
      "position": {
        "x": 2932.384546733161,
        "y": 0.5110396777863571
      },
      "type": "customNode",
      "data": {
        "id": "seqLoop_0",
        "label": "Loop",
        "version": 2.1,
        "name": "seqLoop",
        "type": "Loop",
        "baseClasses": [
          "Loop"
        ],
        "category": "Sequential Agents",
        "description": "Loop back to the specific sequential node",
        "inputParams": [
          {
            "label": "Loop To",
            "name": "loopToName",
            "description": "Name of the agent/llm to loop back to",
            "type": "string",
            "placeholder": "Agent",
            "id": "seqLoop_0-input-loopToName-string"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLoop_0-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "sequentialNode": [
            "{{seqAgent_0.data.instance}}",
            "{{seqAgent_1.data.instance}}",
            "{{seqAgent_2.data.instance}}",
            "{{seqLLMNode_1.data.instance}}"
          ],
          "loopToName": "Supervisor"
        },
        "outputAnchors": [],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 243,
      "selected": false,
      "positionAbsolute": {
        "x": 2932.384546733161,
        "y": 0.5110396777863571
      },
      "dragging": false
    },
    {
      "id": "customMCP_0",
      "position": {
        "x": 1028.3517549415096,
        "y": 1317.5884040361
      },
      "type": "customNode",
      "data": {
        "id": "customMCP_0",
        "label": "Custom MCP",
        "version": 1,
        "name": "customMCP",
        "type": "Custom MCP Tool",
        "baseClasses": [
          "Tool"
        ],
        "category": "Tools (MCP)",
        "description": "Custom MCP Config",
        "inputParams": [
          {
            "label": "MCP Server Config",
            "name": "mcpServerConfig",
            "type": "code",
            "hideCodeExecute": true,
            "placeholder": "{\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/allowed/files\"]\n}",
            "id": "customMCP_0-input-mcpServerConfig-code"
          },
          {
            "label": "Available Actions",
            "name": "mcpActions",
            "type": "asyncMultiOptions",
            "loadMethod": "listActions",
            "refresh": true,
            "id": "customMCP_0-input-mcpActions-asyncMultiOptions"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "mcpServerConfig": "{\n  \"command\": \"bun\",\n  \"args\": [\".runtime/index.ts\"]\n}",
          "mcpActions": "[\"browser_click\",\"browser_console_exec\",\"browser_console_view\",\"browser_input\",\"browser_move_mouse\",\"browser_navigate\",\"browser_press_key\",\"browser_scroll_down\",\"browser_scroll_up\",\"browser_select_option\",\"browser_view\"]"
        },
        "outputAnchors": [
          {
            "id": "customMCP_0-output-customMCP-Tool",
            "name": "customMCP",
            "label": "Custom MCP Tool",
            "description": "Custom MCP Config",
            "type": "Tool"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 826,
      "selected": false,
      "positionAbsolute": {
        "x": 1028.3517549415096,
        "y": 1317.5884040361
      },
      "dragging": false
    },
    {
      "id": "braveSearchAPI_0",
      "position": {
        "x": 1029.1683089535106,
        "y": 2147.371182333736
      },
      "type": "customNode",
      "data": {
        "id": "braveSearchAPI_0",
        "label": "BraveSearch API",
        "version": 1,
        "name": "braveSearchAPI",
        "type": "BraveSearchAPI",
        "baseClasses": [
          "BraveSearchAPI",
          "Tool",
          "StructuredTool",
          "Runnable"
        ],
        "category": "Tools",
        "description": "Wrapper around BraveSearch API - a real-time API to access Brave search results",
        "inputParams": [
          {
            "label": "Connect Credential",
            "name": "credential",
            "type": "credential",
            "credentialNames": [
              "braveSearchApi"
            ],
            "id": "braveSearchAPI_0-input-credential-credential"
          }
        ],
        "inputAnchors": [],
        "inputs": {},
        "outputAnchors": [
          {
            "id": "braveSearchAPI_0-output-braveSearchAPI-BraveSearchAPI|Tool|StructuredTool|Runnable",
            "name": "braveSearchAPI",
            "label": "BraveSearchAPI",
            "description": "Wrapper around BraveSearch API - a real-time API to access Brave search results",
            "type": "BraveSearchAPI | Tool | StructuredTool | Runnable"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 276,
      "selected": false,
      "positionAbsolute": {
        "x": 1029.1683089535106,
        "y": 2147.371182333736
      },
      "dragging": false
    },
    {
      "id": "customMCP_1",
      "position": {
        "x": 1360.4815604646615,
        "y": -604.1874410951783
      },
      "type": "customNode",
      "data": {
        "id": "customMCP_1",
        "label": "Custom MCP",
        "version": 1,
        "name": "customMCP",
        "type": "Custom MCP Tool",
        "baseClasses": [
          "Tool"
        ],
        "category": "Tools (MCP)",
        "description": "Custom MCP Config",
        "inputParams": [
          {
            "label": "MCP Server Config",
            "name": "mcpServerConfig",
            "type": "code",
            "hideCodeExecute": true,
            "placeholder": "{\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/allowed/files\"]\n}",
            "id": "customMCP_1-input-mcpServerConfig-code"
          },
          {
            "label": "Available Actions",
            "name": "mcpActions",
            "type": "asyncMultiOptions",
            "loadMethod": "listActions",
            "refresh": true,
            "id": "customMCP_1-input-mcpActions-asyncMultiOptions"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "mcpServerConfig": "{\n  \"command\": \"bun\",\n  \"args\": [\".runtime/index.ts\"]\n}",
          "mcpActions": "[\"file_find_by_name\",\"file_read\",\"file_str_replace\",\"file_write\",\"file_find_in_content\"]"
        },
        "outputAnchors": [
          {
            "id": "customMCP_1-output-customMCP-Tool",
            "name": "customMCP",
            "label": "Custom MCP Tool",
            "description": "Custom MCP Config",
            "type": "Tool"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 658,
      "selected": false,
      "positionAbsolute": {
        "x": 1360.4815604646615,
        "y": -604.1874410951783
      },
      "dragging": false
    },
    {
      "id": "customMCP_2",
      "position": {
        "x": 1359.2449981805003,
        "y": 78.50426275966674
      },
      "type": "customNode",
      "data": {
        "id": "customMCP_2",
        "label": "Custom MCP",
        "version": 1,
        "name": "customMCP",
        "type": "Custom MCP Tool",
        "baseClasses": [
          "Tool"
        ],
        "category": "Tools (MCP)",
        "description": "Custom MCP Config",
        "inputParams": [
          {
            "label": "MCP Server Config",
            "name": "mcpServerConfig",
            "type": "code",
            "hideCodeExecute": true,
            "placeholder": "{\n    \"command\": \"npx\",\n    \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \"/path/to/allowed/files\"]\n}",
            "id": "customMCP_2-input-mcpServerConfig-code"
          },
          {
            "label": "Available Actions",
            "name": "mcpActions",
            "type": "asyncMultiOptions",
            "loadMethod": "listActions",
            "refresh": true,
            "id": "customMCP_2-input-mcpActions-asyncMultiOptions"
          }
        ],
        "inputAnchors": [],
        "inputs": {
          "mcpServerConfig": "{\n  \"command\": \"bun\",\n  \"args\": [\".runtime/index.ts\"]\n}",
          "mcpActions": "[\"shell_exec\",\"shell_kill_process\",\"shell_view\",\"shell_wait\",\"shell_write_to_process\"]"
        },
        "outputAnchors": [
          {
            "id": "customMCP_2-output-customMCP-Tool",
            "name": "customMCP",
            "label": "Custom MCP Tool",
            "description": "Custom MCP Config",
            "type": "Tool"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 683,
      "selected": false,
      "positionAbsolute": {
        "x": 1359.2449981805003,
        "y": 78.50426275966674
      },
      "dragging": false
    },
    {
      "id": "seqLLMNode_1",
      "position": {
        "x": 1899.9200846555111,
        "y": -562.0009787557595
      },
      "type": "customNode",
      "data": {
        "id": "seqLLMNode_1",
        "label": "LLM Node",
        "version": 4.1,
        "name": "seqLLMNode",
        "type": "LLMNode",
        "baseClasses": [
          "LLMNode"
        ],
        "category": "Sequential Agents",
        "description": "Run Chat Model and return the output",
        "inputParams": [
          {
            "label": "Name",
            "name": "llmNodeName",
            "type": "string",
            "placeholder": "LLM",
            "id": "seqLLMNode_1-input-llmNodeName-string"
          },
          {
            "label": "System Prompt",
            "name": "systemMessagePrompt",
            "type": "string",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_1-input-systemMessagePrompt-string"
          },
          {
            "label": "Prepend Messages History",
            "name": "messageHistory",
            "description": "Prepend a list of messages between System Prompt and Human Prompt. This is useful when you want to provide few shot examples",
            "type": "code",
            "hideCodeExecute": true,
            "codeExample": "const { AIMessage, HumanMessage, ToolMessage } = require('@langchain/core/messages');\n\nreturn [\n    new HumanMessage(\"What is 333382 ðŸ¦œ 1932?\"),\n    new AIMessage({\n        content: \"\",\n        tool_calls: [\n        {\n            id: \"12345\",\n            name: \"calulator\",\n            args: {\n                number1: 333382,\n                number2: 1932,\n                operation: \"divide\",\n            },\n        },\n        ],\n    }),\n    new ToolMessage({\n        tool_call_id: \"12345\",\n        content: \"The answer is 172.558.\",\n    }),\n    new AIMessage(\"The answer is 172.558.\"),\n]",
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_1-input-messageHistory-code"
          },
          {
            "label": "Conversation History",
            "name": "conversationHistorySelection",
            "type": "options",
            "options": [
              {
                "label": "User Question",
                "name": "user_question",
                "description": "Use the user question from the historical conversation messages as input."
              },
              {
                "label": "Last Conversation Message",
                "name": "last_message",
                "description": "Use the last conversation message from the historical conversation messages as input."
              },
              {
                "label": "All Conversation Messages",
                "name": "all_messages",
                "description": "Use all conversation messages from the historical conversation messages as input."
              },
              {
                "label": "Empty",
                "name": "empty",
                "description": "Do not use any messages from the conversation history. Ensure to use either System Prompt, Human Prompt, or Messages History."
              }
            ],
            "default": "all_messages",
            "optional": true,
            "description": "Select which messages from the conversation history to include in the prompt. The selected messages will be inserted between the System Prompt (if defined) and [Messages History, Human Prompt].",
            "additionalParams": true,
            "id": "seqLLMNode_1-input-conversationHistorySelection-options"
          },
          {
            "label": "Human Prompt",
            "name": "humanMessagePrompt",
            "type": "string",
            "description": "This prompt will be added at the end of the messages as human message",
            "rows": 4,
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_1-input-humanMessagePrompt-string"
          },
          {
            "label": "Format Prompt Values",
            "name": "promptValues",
            "description": "Assign values to the prompt variables. You can also use $flow.state.<variable-name> to get the state value",
            "type": "json",
            "optional": true,
            "acceptVariable": true,
            "list": true,
            "additionalParams": true,
            "id": "seqLLMNode_1-input-promptValues-json"
          },
          {
            "label": "JSON Structured Output",
            "name": "llmStructuredOutput",
            "type": "datagrid",
            "description": "Instruct the LLM to give output in a JSON structured schema",
            "datagrid": [
              {
                "field": "key",
                "headerName": "Key",
                "editable": true
              },
              {
                "field": "type",
                "headerName": "Type",
                "type": "singleSelect",
                "valueOptions": [
                  "String",
                  "String Array",
                  "Number",
                  "Boolean",
                  "Enum"
                ],
                "editable": true
              },
              {
                "field": "enumValues",
                "headerName": "Enum Values",
                "editable": true
              },
              {
                "field": "description",
                "headerName": "Description",
                "flex": 1,
                "editable": true
              }
            ],
            "optional": true,
            "additionalParams": true,
            "id": "seqLLMNode_1-input-llmStructuredOutput-datagrid"
          },
          {
            "label": "Update State",
            "name": "updateStateMemory",
            "type": "tabs",
            "tabIdentifier": "selectedUpdateStateMemoryTab",
            "default": "updateStateMemoryUI",
            "additionalParams": true,
            "tabs": [
              {
                "label": "Update State (Table)",
                "name": "updateStateMemoryUI",
                "type": "datagrid",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Key and value pair to be updated. For example: if you have the following State:\n    | Key       | Operation     | Default Value     |\n    |-----------|---------------|-------------------|\n    | user      | Replace       |                   |\n\n    You can update the \"user\" value with the following:\n    | Key       | Value     |\n    |-----------|-----------|\n    | user      | john doe  |\n\n2. If you want to use the LLM Node's output as the value to update state, it is available as available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": 'Hello! How can I assist you today?',\n        \"name\": \"\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {},\n        \"tool_calls\": [],\n        \"invalid_tool_calls\": [],\n        \"usage_metadata\": {}\n    }\n    ```\n\n    For example, if the output `content` is the value you want to update the state with, you can do the following:\n    | Key       | Value                     |\n    |-----------|---------------------------|\n    | user      | `$flow.output.content`  |\n\n3. You can get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values",
                "datagrid": [
                  {
                    "field": "key",
                    "headerName": "Key",
                    "type": "asyncSingleSelect",
                    "loadMethod": "loadStateKeys",
                    "flex": 0.5,
                    "editable": true
                  },
                  {
                    "field": "value",
                    "headerName": "Value",
                    "type": "freeSolo",
                    "valueOptions": [
                      {
                        "label": "LLM Node Output (string)",
                        "value": "$flow.output.content"
                      },
                      {
                        "label": "LLM JSON Output Key (string)",
                        "value": "$flow.output.<replace-with-key>"
                      },
                      {
                        "label": "Global variable (string)",
                        "value": "$vars.<variable-name>"
                      },
                      {
                        "label": "Input Question (string)",
                        "value": "$flow.input"
                      },
                      {
                        "label": "Session Id (string)",
                        "value": "$flow.sessionId"
                      },
                      {
                        "label": "Chat Id (string)",
                        "value": "$flow.chatId"
                      },
                      {
                        "label": "Chatflow Id (string)",
                        "value": "$flow.chatflowId"
                      }
                    ],
                    "editable": true,
                    "flex": 1
                  }
                ],
                "optional": true,
                "additionalParams": true
              },
              {
                "label": "Update State (Code)",
                "name": "updateStateMemoryCode",
                "type": "code",
                "hint": {
                  "label": "How to use",
                  "value": "\n1. Return the key value JSON object. For example: if you have the following State:\n    ```json\n    {\n        \"user\": null\n    }\n    ```\n\n    You can update the \"user\" value by returning the following:\n    ```js\n    return {\n        \"user\": \"john doe\"\n    }\n    ```\n\n2. If you want to use the LLM Node's output as the value to update state, it is available as `$flow.output` with the following structure:\n    ```json\n    {\n        \"content\": 'Hello! How can I assist you today?',\n        \"name\": \"\",\n        \"additional_kwargs\": {},\n        \"response_metadata\": {},\n        \"tool_calls\": [],\n        \"invalid_tool_calls\": [],\n        \"usage_metadata\": {}\n    }\n    ```\n\n    For example, if the output `content` is the value you want to update the state with, you can return the following:\n    ```js\n    return {\n        \"user\": $flow.output.content\n    }\n    ```\n\n3. You can also get default flow config, including the current \"state\":\n    - `$flow.sessionId`\n    - `$flow.chatId`\n    - `$flow.chatflowId`\n    - `$flow.input`\n    - `$flow.state`\n\n4. You can get custom variables: `$vars.<variable-name>`\n\n"
                },
                "description": "This is only applicable when you have a custom State at the START node. After agent execution, you might want to update the State values. Must return an object representing the state",
                "hideCodeExecute": true,
                "codeExample": "const result = $flow.output;\n\n/* Suppose we have a custom State schema like this:\n* {\n    aggregate: {\n        value: (x, y) => x.concat(y),\n        default: () => []\n    }\n  }\n*/\n\nreturn {\n  aggregate: [result.content]\n};",
                "optional": true,
                "additionalParams": true
              }
            ],
            "id": "seqLLMNode_1-input-updateStateMemory-tabs"
          }
        ],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Start, Agent, Condition, LLM, Tool Node, Custom Function, Execute Flow",
            "list": true,
            "id": "seqLLMNode_1-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          },
          {
            "label": "Chat Model",
            "name": "model",
            "type": "BaseChatModel",
            "optional": true,
            "description": "Overwrite model to be used for this node",
            "id": "seqLLMNode_1-input-model-BaseChatModel"
          }
        ],
        "inputs": {
          "llmNodeName": "Planner",
          "systemMessagePrompt": "You are a strategic planning expert who specializes in breaking complex tasks into manageable steps with clear dependencies. Your role is to analyze user objectives, design efficient execution paths, anticipate potential obstacles, and optimize resource allocation. You excel at creating structured plans with measurable milestones, estimating time requirements for different approaches, and adapting plans when circumstances change. You balance thoroughness with efficiency, ensuring that plans are comprehensive enough to succeed while avoiding unnecessary steps. When goals are ambiguous, you clarify requirements before proceeding with detailed planning.\n\nCurrent Plan*:\n{plan}\n\nCurrent State:\n{messages}\n\n*Create one if doesn't exists",
          "messageHistory": "",
          "conversationHistorySelection": "empty",
          "humanMessagePrompt": "",
          "sequentialNode": [
            "{{seqCondition_0.data.instance}}"
          ],
          "model": "",
          "promptValues": "{\"plan\":\"$flow.state.plan\",\"messages\":\"$flow.state.messages\"}",
          "llmStructuredOutput": "[{\"key\":\"plan\",\"type\":\"String\",\"enumValues\":\"\",\"description\":\"\",\"actions\":\"\",\"id\":1}]",
          "updateStateMemory": "updateStateMemoryUI",
          "updateStateMemoryUI": "[{\"key\":\"plan\",\"value\":\"$flow.output.plan\",\"actions\":\"\",\"id\":1}]"
        },
        "outputAnchors": [
          {
            "id": "seqLLMNode_1-output-seqLLMNode-LLMNode",
            "name": "seqLLMNode",
            "label": "LLMNode",
            "description": "Run Chat Model and return the output",
            "type": "LLMNode"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 433,
      "selected": false,
      "positionAbsolute": {
        "x": 1899.9200846555111,
        "y": -562.0009787557595
      },
      "dragging": false
    },
    {
      "id": "seqEnd_0",
      "position": {
        "x": 1898.900654960331,
        "y": 2490.7486820360446
      },
      "type": "customNode",
      "data": {
        "id": "seqEnd_0",
        "label": "End",
        "version": 2.1,
        "name": "seqEnd",
        "type": "End",
        "baseClasses": [
          "End"
        ],
        "category": "Sequential Agents",
        "description": "End conversation",
        "inputParams": [],
        "inputAnchors": [
          {
            "label": "Sequential Node",
            "name": "sequentialNode",
            "type": "Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
            "description": "Can be connected to one of the following nodes: Agent, Condition, LLM Node, Tool Node, Custom Function, Execute Flow",
            "id": "seqEnd_0-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
          }
        ],
        "inputs": {
          "sequentialNode": "{{seqCondition_0.data.instance}}"
        },
        "outputAnchors": [],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 144,
      "selected": false,
      "positionAbsolute": {
        "x": 1898.900654960331,
        "y": 2490.7486820360446
      },
      "dragging": false
    },
    {
      "id": "chatGoogleGenerativeAI_0",
      "position": {
        "x": 256.60152504321144,
        "y": 37.08899232284773
      },
      "type": "customNode",
      "data": {
        "id": "chatGoogleGenerativeAI_0",
        "label": "ChatGoogleGenerativeAI",
        "version": 3,
        "name": "chatGoogleGenerativeAI",
        "type": "ChatGoogleGenerativeAI",
        "baseClasses": [
          "ChatGoogleGenerativeAI",
          "LangchainChatGoogleGenerativeAI",
          "BaseChatModel",
          "BaseLanguageModel",
          "Runnable"
        ],
        "category": "Chat Models",
        "description": "Wrapper around Google Gemini large language models that use the Chat endpoint",
        "inputParams": [
          {
            "label": "Connect Credential",
            "name": "credential",
            "type": "credential",
            "credentialNames": [
              "googleGenerativeAI"
            ],
            "optional": false,
            "description": "Google Generative AI credential.",
            "id": "chatGoogleGenerativeAI_0-input-credential-credential"
          },
          {
            "label": "Model Name",
            "name": "modelName",
            "type": "asyncOptions",
            "loadMethod": "listModels",
            "default": "gemini-1.5-flash-latest",
            "id": "chatGoogleGenerativeAI_0-input-modelName-asyncOptions"
          },
          {
            "label": "Custom Model Name",
            "name": "customModelName",
            "type": "string",
            "placeholder": "gemini-1.5-pro-exp-0801",
            "description": "Custom model name to use. If provided, it will override the model selected",
            "additionalParams": true,
            "id": "chatGoogleGenerativeAI_0-input-customModelName-string"
          },
          {
            "label": "Temperature",
            "name": "temperature",
            "type": "number",
            "step": 0.1,
            "default": 0.9,
            "optional": true,
            "id": "chatGoogleGenerativeAI_0-input-temperature-number"
          },
          {
            "label": "Streaming",
            "name": "streaming",
            "type": "boolean",
            "default": true,
            "optional": true,
            "additionalParams": true,
            "id": "chatGoogleGenerativeAI_0-input-streaming-boolean"
          },
          {
            "label": "Max Output Tokens",
            "name": "maxOutputTokens",
            "type": "number",
            "step": 1,
            "optional": true,
            "additionalParams": true,
            "id": "chatGoogleGenerativeAI_0-input-maxOutputTokens-number"
          },
          {
            "label": "Top Probability",
            "name": "topP",
            "type": "number",
            "step": 0.1,
            "optional": true,
            "additionalParams": true,
            "id": "chatGoogleGenerativeAI_0-input-topP-number"
          },
          {
            "label": "Top Next Highest Probability Tokens",
            "name": "topK",
            "type": "number",
            "description": "Decode using top-k sampling: consider the set of top_k most probable tokens. Must be positive",
            "step": 1,
            "optional": true,
            "additionalParams": true,
            "id": "chatGoogleGenerativeAI_0-input-topK-number"
          },
          {
            "label": "Harm Category",
            "name": "harmCategory",
            "type": "multiOptions",
            "description": "Refer to <a target=\"_blank\" href=\"https://cloud.google.com/vertex-ai/docs/generative-ai/multimodal/configure-safety-attributes#safety_attribute_definitions\">official guide</a> on how to use Harm Category",
            "options": [
              {
                "label": "Dangerous",
                "name": "HARM_CATEGORY_DANGEROUS_CONTENT"
              },
              {
                "label": "Harassment",
                "name": "HARM_CATEGORY_HARASSMENT"
              },
              {
                "label": "Hate Speech",
                "name": "HARM_CATEGORY_HATE_SPEECH"
              },
              {
                "label": "Sexually Explicit",
                "name": "HARM_CATEGORY_SEXUALLY_EXPLICIT"
              }
            ],
            "optional": true,
            "additionalParams": true,
            "id": "chatGoogleGenerativeAI_0-input-harmCategory-multiOptions"
          },
          {
            "label": "Harm Block Threshold",
            "name": "harmBlockThreshold",
            "type": "multiOptions",
            "description": "Refer to <a target=\"_blank\" href=\"https://cloud.google.com/vertex-ai/docs/generative-ai/multimodal/configure-safety-attributes#safety_setting_thresholds\">official guide</a> on how to use Harm Block Threshold",
            "options": [
              {
                "label": "Low and Above",
                "name": "BLOCK_LOW_AND_ABOVE"
              },
              {
                "label": "Medium and Above",
                "name": "BLOCK_MEDIUM_AND_ABOVE"
              },
              {
                "label": "None",
                "name": "BLOCK_NONE"
              },
              {
                "label": "Only High",
                "name": "BLOCK_ONLY_HIGH"
              },
              {
                "label": "Threshold Unspecified",
                "name": "HARM_BLOCK_THRESHOLD_UNSPECIFIED"
              }
            ],
            "optional": true,
            "additionalParams": true,
            "id": "chatGoogleGenerativeAI_0-input-harmBlockThreshold-multiOptions"
          },
          {
            "label": "Allow Image Uploads",
            "name": "allowImageUploads",
            "type": "boolean",
            "description": "Allow image input. Refer to the <a href=\"https://docs.flowiseai.com/using-flowise/uploads#image\" target=\"_blank\">docs</a> for more details.",
            "default": false,
            "optional": true,
            "id": "chatGoogleGenerativeAI_0-input-allowImageUploads-boolean"
          }
        ],
        "inputAnchors": [
          {
            "label": "Cache",
            "name": "cache",
            "type": "BaseCache",
            "optional": true,
            "id": "chatGoogleGenerativeAI_0-input-cache-BaseCache"
          }
        ],
        "inputs": {
          "cache": "",
          "modelName": "gemini-2.0-flash-001",
          "customModelName": "",
          "temperature": "0.2",
          "streaming": true,
          "maxOutputTokens": "",
          "topP": "",
          "topK": "",
          "harmCategory": "",
          "harmBlockThreshold": "",
          "allowImageUploads": true
        },
        "outputAnchors": [
          {
            "id": "chatGoogleGenerativeAI_0-output-chatGoogleGenerativeAI-ChatGoogleGenerativeAI|LangchainChatGoogleGenerativeAI|BaseChatModel|BaseLanguageModel|Runnable",
            "name": "chatGoogleGenerativeAI",
            "label": "ChatGoogleGenerativeAI",
            "description": "Wrapper around Google Gemini large language models that use the Chat endpoint",
            "type": "ChatGoogleGenerativeAI | LangchainChatGoogleGenerativeAI | BaseChatModel | BaseLanguageModel | Runnable"
          }
        ],
        "outputs": {},
        "selected": false
      },
      "width": 300,
      "height": 671,
      "positionAbsolute": {
        "x": 256.60152504321144,
        "y": 37.08899232284773
      },
      "selected": false,
      "dragging": false
    }
  ],
  "edges": [
    {
      "source": "sqliteAgentMemory_0",
      "sourceHandle": "sqliteAgentMemory_0-output-sqliteAgentMemory-SQLiteAgentMemory|BaseCheckpointSaver",
      "target": "seqStart_0",
      "targetHandle": "seqStart_0-input-agentMemory-BaseCheckpointSaver",
      "type": "buttonedge",
      "id": "sqliteAgentMemory_0-sqliteAgentMemory_0-output-sqliteAgentMemory-SQLiteAgentMemory|BaseCheckpointSaver-seqStart_0-seqStart_0-input-agentMemory-BaseCheckpointSaver"
    },
    {
      "source": "seqState_0",
      "sourceHandle": "seqState_0-output-seqState-State",
      "target": "seqStart_0",
      "targetHandle": "seqStart_0-input-state-State",
      "type": "buttonedge",
      "id": "seqState_0-seqState_0-output-seqState-State-seqStart_0-seqStart_0-input-state-State"
    },
    {
      "source": "seqStart_0",
      "sourceHandle": "seqStart_0-output-seqStart-Start",
      "target": "seqLLMNode_0",
      "targetHandle": "seqLLMNode_0-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqStart_0-seqStart_0-output-seqStart-Start-seqLLMNode_0-seqLLMNode_0-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
    },
    {
      "source": "seqLLMNode_0",
      "sourceHandle": "seqLLMNode_0-output-seqLLMNode-LLMNode",
      "target": "seqCondition_0",
      "targetHandle": "seqCondition_0-input-sequentialNode-Start | Agent | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqLLMNode_0-seqLLMNode_0-output-seqLLMNode-LLMNode-seqCondition_0-seqCondition_0-input-sequentialNode-Start | Agent | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
    },
    {
      "source": "seqAgent_0",
      "sourceHandle": "seqAgent_0-output-seqAgent-Agent",
      "target": "seqLoop_0",
      "targetHandle": "seqLoop_0-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqAgent_0-seqAgent_0-output-seqAgent-Agent-seqLoop_0-seqLoop_0-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqAgent_1",
      "sourceHandle": "seqAgent_1-output-seqAgent-Agent",
      "target": "seqLoop_0",
      "targetHandle": "seqLoop_0-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqAgent_1-seqAgent_1-output-seqAgent-Agent-seqLoop_0-seqLoop_0-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "seqAgent_2",
      "sourceHandle": "seqAgent_2-output-seqAgent-Agent",
      "target": "seqLoop_0",
      "targetHandle": "seqLoop_0-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqAgent_2-seqAgent_2-output-seqAgent-Agent-seqLoop_0-seqLoop_0-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "selected": false
    },
    {
      "source": "braveSearchAPI_0",
      "sourceHandle": "braveSearchAPI_0-output-braveSearchAPI-BraveSearchAPI|Tool|StructuredTool|Runnable",
      "target": "seqAgent_2",
      "targetHandle": "seqAgent_2-input-tools-Tool",
      "type": "buttonedge",
      "id": "braveSearchAPI_0-braveSearchAPI_0-output-braveSearchAPI-BraveSearchAPI|Tool|StructuredTool|Runnable-seqAgent_2-seqAgent_2-input-tools-Tool",
      "selected": false
    },
    {
      "source": "customMCP_0",
      "sourceHandle": "customMCP_0-output-customMCP-Tool",
      "target": "seqAgent_2",
      "targetHandle": "seqAgent_2-input-tools-Tool",
      "type": "buttonedge",
      "id": "customMCP_0-customMCP_0-output-customMCP-Tool-seqAgent_2-seqAgent_2-input-tools-Tool"
    },
    {
      "source": "customMCP_2",
      "sourceHandle": "customMCP_2-output-customMCP-Tool",
      "target": "seqAgent_1",
      "targetHandle": "seqAgent_1-input-tools-Tool",
      "type": "buttonedge",
      "id": "customMCP_2-customMCP_2-output-customMCP-Tool-seqAgent_1-seqAgent_1-input-tools-Tool"
    },
    {
      "source": "customMCP_1",
      "sourceHandle": "customMCP_1-output-customMCP-Tool",
      "target": "seqAgent_0",
      "targetHandle": "seqAgent_0-input-tools-Tool",
      "type": "buttonedge",
      "id": "customMCP_1-customMCP_1-output-customMCP-Tool-seqAgent_0-seqAgent_0-input-tools-Tool"
    },
    {
      "source": "seqLLMNode_1",
      "sourceHandle": "seqLLMNode_1-output-seqLLMNode-LLMNode",
      "target": "seqLoop_0",
      "targetHandle": "seqLoop_0-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqLLMNode_1-seqLLMNode_1-output-seqLLMNode-LLMNode-seqLoop_0-seqLoop_0-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
    },
    {
      "source": "seqCondition_0",
      "sourceHandle": "seqCondition_0-output-planner-Condition",
      "target": "seqLLMNode_1",
      "targetHandle": "seqLLMNode_1-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCondition_0-seqCondition_0-output-planner-Condition-seqLLMNode_1-seqLLMNode_1-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
    },
    {
      "source": "seqCondition_0",
      "sourceHandle": "seqCondition_0-output-webnavigator-Condition",
      "target": "seqAgent_2",
      "targetHandle": "seqAgent_2-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCondition_0-seqCondition_0-output-webnavigator-Condition-seqAgent_2-seqAgent_2-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
    },
    {
      "source": "seqCondition_0",
      "sourceHandle": "seqCondition_0-output-filewizard-Condition",
      "target": "seqAgent_0",
      "targetHandle": "seqAgent_0-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCondition_0-seqCondition_0-output-filewizard-Condition-seqAgent_0-seqAgent_0-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
    },
    {
      "source": "seqCondition_0",
      "sourceHandle": "seqCondition_0-output-commandrunner-Condition",
      "target": "seqAgent_1",
      "targetHandle": "seqAgent_1-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCondition_0-seqCondition_0-output-commandrunner-Condition-seqAgent_1-seqAgent_1-input-sequentialNode-Start | Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
    },
    {
      "source": "seqCondition_0",
      "sourceHandle": "seqCondition_0-output-end-Condition",
      "target": "seqEnd_0",
      "targetHandle": "seqEnd_0-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow",
      "type": "buttonedge",
      "id": "seqCondition_0-seqCondition_0-output-end-Condition-seqEnd_0-seqEnd_0-input-sequentialNode-Agent | Condition | LLMNode | ToolNode | CustomFunction | ExecuteFlow"
    },
    {
      "source": "chatGoogleGenerativeAI_0",
      "sourceHandle": "chatGoogleGenerativeAI_0-output-chatGoogleGenerativeAI-ChatGoogleGenerativeAI|LangchainChatGoogleGenerativeAI|BaseChatModel|BaseLanguageModel|Runnable",
      "target": "seqStart_0",
      "targetHandle": "seqStart_0-input-model-BaseChatModel",
      "type": "buttonedge",
      "id": "chatGoogleGenerativeAI_0-chatGoogleGenerativeAI_0-output-chatGoogleGenerativeAI-ChatGoogleGenerativeAI|LangchainChatGoogleGenerativeAI|BaseChatModel|BaseLanguageModel|Runnable-seqStart_0-seqStart_0-input-model-BaseChatModel"
    }
  ]
}